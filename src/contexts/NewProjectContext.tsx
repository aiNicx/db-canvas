import { createContext, useContext, useEffect, useState } from "react";
import { toast } from "sonner";
import { v4 as uuidv4 } from "uuid";
import { Project, ProjectContextType } from "@/types/schema"; // Import type from schema
import { useTables } from "@/hooks/useTables";
import { useConnections } from "@/hooks/useConnections";
import { ProjectContext } from "./ProjectContextObject"; // Import context object

// Type definition removed (now in src/types/schema.ts)

// Context creation removed (now in src/contexts/ProjectContextObject.ts)

export const ProjectProvider = ({ children }: { children: React.ReactNode }) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [currentProject, setCurrentProject] = useState<Project | null>(null);

  // Initialize from localStorage
  useEffect(() => {
    const storedProjects = localStorage.getItem("db-canvas-projects");
    if (storedProjects) {
      try {
        setProjects(JSON.parse(storedProjects));
      } catch (error) {
        console.error("Failed to parse stored projects", error);
        toast.error("Failed to load stored projects");
      }
    }
  }, []);

  // Persist to localStorage
  useEffect(() => {
    if (projects.length > 0) {
      localStorage.setItem("db-canvas-projects", JSON.stringify(projects));
    }
  }, [projects]);

  
  // Updated updateProject to accept an updater function
  const updateProject = (updater: (prevProject: Project | null) => Project) => {
    setCurrentProject(prevCurrent => {
      if (!prevCurrent) return null; // Should not happen if updating, but safety check
      const updatedProject = updater(prevCurrent);
      
      // Update the list of all projects as well
      setProjects(prevProjects =>
        prevProjects.map(p => p.id === updatedProject.id ? updatedProject : p)
      );
      
      return updatedProject; // Return the updated project for setCurrentProject
    });
  };
  
  // Initialize hooks
  // Pass the new updateProject function to the hooks
  const tablesApi = useTables(currentProject, updateProject);
  const connectionsApi = useConnections(currentProject, updateProject);
  const createProject = (name: string) => {
    const newProject: Project = {
      id: uuidv4(),
      name,
      tables: [],
      connections: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    setProjects(prev => [...prev, newProject]);
    setCurrentProject(newProject);
    toast.success(`Project "${name}" created`);
    return newProject; // Return the newly created project
  };

  const openProject = (id: string) => {
    const project = projects.find(p => p.id === id);
    if (project) {
      setCurrentProject(project);
    } else {
      toast.error("Project not found");
    }
  };

  const deleteProject = (id: string) => {
    setProjects(prev => prev.filter(p => p.id !== id));
    if (currentProject?.id === id) {
      setCurrentProject(null);
    }
  };

  const duplicateProject = (id: string) => {
    const project = projects.find(p => p.id === id);
    if (project) {
      const newProject = {
        ...project,
        id: crypto.randomUUID(),
        name: `${project.name} (Copy)`,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      setProjects(prev => [...prev, newProject]);
    }
  };


  const exportProjectSQL = (id: string, dbType: "mysql" | "postgresql" | "sqlite"): string => {
    const project = projects.find((p) => p.id === id);
    if (!project) {
      toast.error("Project not found");
      return "";
    }
    
    let sql = `-- ${project.name} SQL Schema\n-- Generated by DB Canvas\n-- ${new Date().toISOString()}\n\n`;
    
    project.tables.forEach(table => {
      sql += `CREATE TABLE ${table.name} (\n`;
      
      table.fields.forEach((field, index) => {
        const comma = index < table.fields.length - 1 ? ',' : '';
        sql += `  ${field.name} ${field.type}${field.notNull ? ' NOT NULL' : ''}${field.defaultValue ? ` DEFAULT ${field.defaultValue}` : ''}${field.primary ? ' PRIMARY KEY' : ''}${field.unique && !field.primary ? ' UNIQUE' : ''}${comma}\n`;
      });
      
      sql += `);\n\n`;
    });
    
    project.connections.forEach(connection => {
      const sourceTable = project.tables.find(t => t.id === connection.sourceId);
      const targetTable = project.tables.find(t => t.id === connection.targetId);
      
      if (sourceTable && targetTable) {
        sql += `ALTER TABLE ${sourceTable.name} ADD CONSTRAINT fk_${sourceTable.name}_${connection.sourceField}_${targetTable.name} `;
        sql += `FOREIGN KEY (${connection.sourceField}) REFERENCES ${targetTable.name}(${connection.targetField})`;
        
        // Basic ON DELETE behavior - adjust as needed for specific dialects/requirements
        if (connection.relationshipType === "oneToMany") {
          sql += ` ON DELETE CASCADE`; // Common default for one-to-many
        } else { // oneToOne
          sql += ` ON DELETE RESTRICT`; // Common default for one-to-one
        }
        
        sql += `;\n`;
      }
    });
    
    return sql;
  };


  return (
    <ProjectContext.Provider
      value={{
        projects,
        currentProject,
        tablesApi,
        connectionsApi,
        createProject,
        openProject,
        deleteProject,
        duplicateProject,
        updateFullProject: updateProject, // Assign the internal update function
        exportProjectSQL // Add the export function to the context value
      }}
    >
      {children}
    </ProjectContext.Provider>
  );
};

// Removed useProject hook - it's now in src/hooks/useProject.ts