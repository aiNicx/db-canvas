import { createContext, useContext, useEffect, useState } from "react";
import { toast } from "sonner";
import { v4 as uuidv4 } from "uuid";
import { TableNode, Connection, Project, Position } from "@/types/schema";

interface ProjectContextType {
  projects: Project[];
  currentProject: Project | null;
  createProject: (name: string) => Project;
  openProject: (id: string) => void;
  updateProject: (project: Project) => void;
  deleteProject: (id: string) => void;
  duplicateProject: (id: string) => void;
  exportProjectSQL: (id: string, dbType: "mysql" | "postgresql" | "sqlite") => string;
  importProject: (sqlContent: string) => Project | null;
  addTable: (table: Omit<TableNode, "id" | "position">, position: Position) => TableNode;
  updateTable: (table: TableNode) => void;
  deleteTable: (id: string) => void;
  addConnection: (connection: Omit<Connection, "id">) => Connection;
  updateConnection: (connection: Connection) => void;
  deleteConnection: (id: string) => void;
}

const ProjectContext = createContext<ProjectContextType | undefined>(undefined);

export const ProjectProvider = ({ children }: { children: React.ReactNode }) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [currentProject, setCurrentProject] = useState<Project | null>(null);

  useEffect(() => {
    const storedProjects = localStorage.getItem("db-canvas-projects");
    if (storedProjects) {
      try {
        setProjects(JSON.parse(storedProjects));
      } catch (error) {
        console.error("Failed to parse stored projects", error);
        toast.error("Failed to load stored projects");
      }
    }
  }, []);

  useEffect(() => {
    if (projects.length > 0) {
      localStorage.setItem("db-canvas-projects", JSON.stringify(projects));
    }
  }, [projects]);

  const createProject = (name: string): Project => {
    const newProject: Project = {
      id: uuidv4(),
      name,
      tables: [],
      connections: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    setProjects((prev) => [...prev, newProject]);
    setCurrentProject(newProject);
    toast.success(`Project "${name}" created`);
    return newProject;
  };

  const openProject = (id: string) => {
    const project = projects.find((p) => p.id === id);
    if (project) {
      setCurrentProject(project);
    } else {
      toast.error("Project not found");
    }
  };

  const updateProject = (project: Project) => {
    setProjects((prev) =>
      prev.map((p) =>
        p.id === project.id
          ? { ...project, updatedAt: new Date().toISOString() }
          : p
      )
    );
    if (currentProject?.id === project.id) {
      setCurrentProject({ ...project, updatedAt: new Date().toISOString() });
    }
  };

  const deleteProject = (id: string) => {
    const project = projects.find((p) => p.id === id);
    setProjects((prev) => prev.filter((p) => p.id !== id));
    if (currentProject?.id === id) {
      setCurrentProject(null);
    }
    if (project) {
      toast.success(`Project "${project.name}" deleted`);
    }
  };

  const duplicateProject = (id: string) => {
    const project = projects.find((p) => p.id === id);
    if (project) {
      const newProject: Project = {
        ...project,
        id: uuidv4(),
        name: `${project.name} (Copy)`,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      setProjects((prev) => [...prev, newProject]);
      toast.success(`Project "${project.name}" duplicated`);
      return newProject;
    }
    toast.error("Project not found");
    return null;
  };

  const exportProjectSQL = (id: string, dbType: "mysql" | "postgresql" | "sqlite"): string => {
    const project = projects.find((p) => p.id === id);
    if (!project) {
      toast.error("Project not found");
      return "";
    }
    
    let sql = `-- ${project.name} SQL Schema\n-- Generated by DB Canvas\n-- ${new Date().toISOString()}\n\n`;
    
    project.tables.forEach(table => {
      sql += `CREATE TABLE ${table.name} (\n`;
      
      table.fields.forEach((field, index) => {
        const comma = index < table.fields.length - 1 ? ',' : '';
        sql += `  ${field.name} ${field.type}${field.notNull ? ' NOT NULL' : ''}${field.defaultValue ? ` DEFAULT ${field.defaultValue}` : ''}${field.primary ? ' PRIMARY KEY' : ''}${field.unique && !field.primary ? ' UNIQUE' : ''}${comma}\n`;
      });
      
      sql += `);\n\n`;
    });
    
    project.connections.forEach(connection => {
      const sourceTable = project.tables.find(t => t.id === connection.sourceId);
      const targetTable = project.tables.find(t => t.id === connection.targetId);
      
      if (sourceTable && targetTable) {
        sql += `ALTER TABLE ${sourceTable.name} ADD CONSTRAINT fk_${sourceTable.name}_${connection.sourceField}_${targetTable.name} `;
        sql += `FOREIGN KEY (${connection.sourceField}) REFERENCES ${targetTable.name}(${connection.targetField})`;
        
        if (connection.relationshipType === "oneToMany") {
          sql += ` ON DELETE CASCADE`;
        } else {
          sql += ` ON DELETE RESTRICT`;
        }
        
        sql += `;\n`;
      }
    });
    
    return sql;
  };

  const importProject = (sqlContent: string): Project | null => {
    try {
      const newProject: Project = {
        id: uuidv4(),
        name: "Imported Project",
        tables: [],
        connections: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      
      setProjects(prev => [...prev, newProject]);
      toast.success("Project imported successfully");
      return newProject;
    } catch (error) {
      console.error("Failed to import project", error);
      toast.error("Failed to import project");
      return null;
    }
  };

  const addTable = (
    table: Omit<TableNode, "id" | "position">,
    position: Position
  ): TableNode => {
    if (!currentProject) {
      toast.error("No project open");
      throw new Error("No project open");
    }

    const newTable: TableNode = {
      id: uuidv4(),
      ...table,
      position,
    };

    const updatedProject = {
      ...currentProject,
      tables: [...currentProject.tables, newTable],
      updatedAt: new Date().toISOString(),
    };

    updateProject(updatedProject);
    return newTable;
  };

  const updateTable = (table: TableNode) => {
    if (!currentProject) {
      toast.error("No project open");
      return;
    }

    const updatedProject = {
      ...currentProject,
      tables: currentProject.tables.map((t) =>
        t.id === table.id ? table : t
      ),
      updatedAt: new Date().toISOString(),
    };

    updateProject(updatedProject);
  };

  const deleteTable = (id: string) => {
    if (!currentProject) {
      toast.error("No project open");
      return;
    }

    const updatedProject = {
      ...currentProject,
      tables: currentProject.tables.filter((t) => t.id !== id),
      connections: currentProject.connections.filter(
        (c) => c.sourceId !== id && c.targetId !== id
      ),
      updatedAt: new Date().toISOString(),
    };

    updateProject(updatedProject);
  };

  const addConnection = (
    connection: Omit<Connection, "id">
  ): Connection => {
    if (!currentProject) {
      toast.error("No project open");
      throw new Error("No project open");
    }

    const newConnection: Connection = {
      id: uuidv4(),
      ...connection,
    };

    const updatedProject = {
      ...currentProject,
      connections: [...currentProject.connections, newConnection],
      updatedAt: new Date().toISOString(),
    };

    updateProject(updatedProject);
    return newConnection;
  };

  const updateConnection = (connection: Connection) => {
    if (!currentProject) {
      toast.error("No project open");
      return;
    }

    const updatedProject = {
      ...currentProject,
      connections: currentProject.connections.map((c) =>
        c.id === connection.id ? connection : c
      ),
      updatedAt: new Date().toISOString(),
    };

    updateProject(updatedProject);
  };

  const deleteConnection = (id: string) => {
    if (!currentProject) {
      toast.error("No project open");
      return;
    }

    const updatedProject = {
      ...currentProject,
      connections: currentProject.connections.filter((c) => c.id !== id),
      updatedAt: new Date().toISOString(),
    };

    updateProject(updatedProject);
  };

  return (
    <ProjectContext.Provider
      value={{
        projects,
        currentProject,
        createProject,
        openProject,
        updateProject,
        deleteProject,
        duplicateProject,
        exportProjectSQL,
        importProject,
        addTable,
        updateTable,
        deleteTable,
        addConnection,
        updateConnection,
        deleteConnection,
      }}
    >
      {children}
    </ProjectContext.Provider>
  );
};

export const useProject = () => {
  const context = useContext(ProjectContext);
  if (context === undefined) {
    throw new Error("useProject must be used within a ProjectProvider");
  }
  return context;
};
